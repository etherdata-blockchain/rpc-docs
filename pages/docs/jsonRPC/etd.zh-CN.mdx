---
title: etd Namespace
---

Getd 为标准的“etd”JSON-RPC 命名空间提供了多个扩展。

## etd_subscribe, etd_unsubscribe

这些方法通过订阅用于实时事件。有关详细信息，请参阅<a href="https://Getd.ethereum.org/docs/rpc/pubsub" title="订阅文档">订阅文档</a>。

## etd_call

立即执行新消息调用，无需在区块链上创建交易。 `etd_call` 方法可用于查询内部合约状态，执行编码到合约中的验证，甚至测试交易在不实时运行的情况下的效果。

＃＃＃ 参数

该方法接受 3 个参数：一个以只读模式执行的未签名事务对象；执行调用的块号；以及一个可选的状态覆盖集，以允许针对修改后的链状态执行调用。

1. `Object` - 交易调用对象
   交易调用对象是强制性的，包含执行只读 EVM 合约方法所需的所有参数。
   
| 域      | 类型       | 字节数 | 是否可选 | 描述                                                                                          |
| ----------- | ---------- | ----- | -------- | ----------------------------------------------------------------------------------------------------- |
| `from`     | `Address` | 20    | 是  | 模拟交易发送的地址。 如果没有可用的本地帐户，则默认为本地密钥库中的第一个帐户或“0x00..0”地址。      |
| `to`       | `Address` | 20    | 否 | 交易发送到的地址。  |
| `gas`      | `Quality` | `<8`    | 是 |代码执行的最大 gas 限额，以避免无限循环。 默认为 `2^63` 或节点操作符通过 `--rpc.gascap` 指定的任何值。    |
| `gasprice` | `Quality` | `<32`   |是   | 在执行期间模拟为每单位 gas 支付的 `wei` 数量。 默认为`1``gwei`。                                                                                                                                                                                          |
| `value`    | `Quality` | `<32`   | 是   | 与交易一起模拟发送的“wei”数量。 默认为“0”。    |
| `data`     | `Binary`  | any   | 是   | 要发送到目标合约的二进制数据。 通常是方法签名的 4 字节散列，后跟 ABI 编码参数。 详情请参见<a href="https://github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI" title="以太坊合约ABI">以太坊合约ABI</a>。 |

### 代码示例:

```javascript
{
  "from": "0xd9c9cd5f6779558b6e0ed4e6acf6b1947e7fa1f3",
  "to":   "0xebe8efa441b9302a0d7eaecc277c09d20d684540",
  "gas":  "0x1bd7c",
  "data": "0xd459fc46000000000000000000000000000000000000000000000000000000000046c650dbb5e8cb2bac4d2ed0b1e6475d37361157738801c494ca482f96527eb48f9eec488c2eba92d31baeccfb6968fad5c21a3df93181b43b4cf253b4d572b64172ef000000000000000000000000000000000000000000000000000000000000008c00000000000000000000000000000000000000000000000000000000000000e0000000000000000000000000000000000000000000000000000000000000014000000000000000000000000000000000000000000000000000000000000001a00000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000001c000000000000000000000000000000000000000000000000000000000000001c0000000000000000000000000000000000000000000000000000000000000002b85c0c828d7a98633b4e1b65eac0c017502da909420aeade9a280675013df36bdc71cffdf420cef3d24ba4b3f9b980bfbb26bd5e2dcf7795b3519a3fd22ffbb2000000000000000000000000000000000000000000000000000000000000000238fb6606dc2b5e42d00c653372c153da8560de77bd9afaba94b4ab6e4aa11d565d858c761320dbf23a94018d843772349bd9d92301b0ca9ca983a22d86a70628",
}
```

2.`数量| Tag` - 块号或字符串最新或待定
    块号是强制性的，它定义了应该执行指定事务的上下文（状态）。 无法对重组块执行调用； 或早于 128 的块（除非该节点是存档节点）。

3. `Object` - 状态覆盖集
    状态覆盖集是一个可选的地址到状态映射，其中每个条目指定在执行调用之前临时覆盖的一些状态。 每个地址映射到一个对象，其中包含： 
	
| 域      | 类型       | 字节数 | 是否可选 | 描述                                                                                          |
| ----------- | ---------- | ----- | -------- | ----------------------------------------------------------------------------------------------------- |
| `balance`   | `Quantity` | `<32`   | 是      | 在执行呼叫之前为帐户设置假余额。                       |
| `nonce`     | `Quantity` | `<8`    | 是      | 在执行调用之前为帐户设置假随机数。                     |
| `code`      | `Binary`   | 任意值  | 是    | 在执行调用之前将伪造的 EVM 字节码注入到帐户中。           |
| `state`     | `Object`   | 任意值  | 是      | 在执行调用之前，伪造键值映射以覆盖帐户存储中的所有插槽。   |
| `stateDiff` | `Object`   | 任意值  | 是     | 在执行调用之前，伪造键值映射以覆盖帐户存储中的各个插槽。   |

状态覆盖集的目标是多方面的：

- DApps 可以使用它来减少需要部署在链上的合约代码量。 简单地返回内部状态或执行预定义验证的代码可以保持在链外并按需提供给节点。
- 通过使用自定义方法扩展部署在链上的代码并调用它们，可用于智能合约分析。 这避免了必须在沙箱中下载和重建整个状态来运行自定义代码。
- 通过有选择地覆盖一些代码或状态并查看执行如何变化，它可用于调试已部署的大型合约套件中的智能合约。 可能需要专门的工具。

### 代码示例

```javascript
{
  "0xd9c9cd5f6779558b6e0ed4e6acf6b1947e7fa1f3": {
    "balance": "0xde0b6b3a7640000"
  },
  "0xebe8efa441b9302a0d7eaecc277c09d20d684540": {
    "code": "0x...",
    "state": {
      ""
    }
  }
}
```

### 返回值

该方法返回一个“二进制”，其中包含执行的合约调用的返回值。

### 简单的例子

通过在本地主机上公开 RPC 的同步 Rinkeby 节点（`Getd --rinkeby --http`），我们可以调用 Checkpoint Oracle 以检索管理员列表：

```javascript
$ curl --data '{"method":"etd_call","params":[{"to":"0xebe8efa441b9302a0d7eaecc277c09d20d684540","data":"0x45848dfc"},"latest"],"id" jsonrpc":"2.0"}' -H "Content-Type: application/json" -X POST localhost:8545
``

结果是一个以太坊 ABI 编码的账户列表： 

```javascript
{
  "id":      1,
  "jsonrpc": "2.0",
  "result":  "0x00000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000004000000000000000000000000d9c9cd5f6779558b6e0ed4e6acf6b1947e7fa1f300000000000000000000000078d1ad571a1a09d60d9bbf25894b44e4c8859595000000000000000000000000286834935f4a8cfb4ff4c77d5770c2775ae2b0e7000000000000000000000000b86e2b0ab5a4b1373e40c51a7c712c70ba2f9f8e"
}
```

为了完整起见，解码后的响应是：

```javascript
0xd9c9cd5f6779558b6e0ed4e6acf6b1947e7fa1f3,
0x78d1ad571a1a09d60d9bbf25894b44e4c8859595,
0x286834935f4a8cfb4ff4c77d5770c2775ae2b0e7,
0xb86e2b0ab5a4b1373e40c51a7c712c70ba2f9f8e
```

### 覆盖示例

上面的简单示例展示了如何调用链上智能合约已经公开的方法。 如果我们想访问一些它没有公开的数据怎么办？

我们可以删除 <a href="https://github.com/ethereum/go-ethereum/blob/master/contracts/checkpointoracle/contract/oracle.sol" title="original">original</a> 检查点 oracle 与一个保留相同字段（以保留相同的存储布局）但包含不同方法集的合同：

```javascript
pragma solidity ^0.5.10;

contract CheckpointOracle {
    mapping(address => bool) admins;
    address[] adminList;
    uint64 sectionIndex;
    uint height;
    bytes32 hash;
    uint sectionSize;
    uint processConfirms;
    uint threshold;

    function VotingThreshold() public view returns (uint) {
        return threshold;
    }
}
```

通过在本地主机上公开 RPC 的同步 Rinkeby 节点（`Getd --rinkeby --http`），我们可以调用实时 <a href="https://rinkeby.etherscan.io/address/0xebe8efa441b9302a0d7eaecc277c09d20d684540" title= "Checkpoint Oracle">Checkpoint Oracle</a>，但使用我们自己的版本覆盖其字节码，该版本具有投票阈值字段的访问器：

```javascript
$ curl --data '{"method":"etd_call","params":[{"to":"0xebe8efa441b9302a0d7eaecc277c09d20d684540","data":"0x0be5b6ba"}, "latest", {"0xebe8efa441b9302a0d7eaecc277c09d20d684540": {"code":"0x6080604052348015600f57600080fd5b506004361060285760003560e01c80630be5b6ba14602d575b600080fd5b60336045565b60408051918252519081900360200190f35b6007549056fea265627a7a723058206f26bd0433456354d8d1228d8fe524678a8aeeb0594851395bdbd35efc2a65f164736f6c634300050a0032"}}],"id":1,"jsonrpc":"2.0"}' -H "Content-Type: application/json" -X POST localhost:8545
```

结果是以太坊 ABI 编码的阈值数：

```json
{
"id": 1,
"jsonrpc": "2.0",
"result": "0x0000000000000000000000000000000000000000000000000000000000000002"
}
```

为了完整起见，解码后的响应是：`2`。